{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Programming with functions\"\noutput:\n  github_document: default\n  html_document: default\n  pdf_document: default\n---\n\n### Functions\n\nA function has a form:\n```{r, eval=FALSE}\nname <- function(argument_1, argument_2, ...) {\n  expression_1\n  expression_2\n  ...\n  return(output)\n}\n```\n* ```argument_1, arguments_2``` are the names of variables.\n* ```name``` is the name of function. You change ```name``` as you want.\n\nTo call or run the function we type:\n```{r, eval=FALSE}\nname(x1, x2, …)\n```\nthe value of this expression is the value of output.\n\n* A function may have more than one ```return``` statement, in which case it stops after executing the first one it reaches.\n* If there is no statement ```return(output)`` then the value returned by the function is the value of the last expression in the braces.\n\n* A function always returns a value.\n  * For some functions the value returned is unimportant.\n  * In such cases one usually omits the return statement, or returns NULL.\n* If the value returned by a function is not assigned to a variable, then it is printed.\n\n* The most important advantage of using a function is that once it is loaded, it can be used again and again without having to reload it.\n\n* The second most important use of functions is to break down a programming task into smaller logical units.\n\n#### Example : Find zeros of ```a2*x^2+a1*x+a0=0```\n\n```{r}\nquad3 <- function(a0, a1, a2) {\n  if(a2 == 0 && a1 == 0 && a0 == 0) {\n    roots <- NA\t\n  } else if (a2 == 0 && a1 == 0 ) {\n\t  roots <- NULL\n  } else if ( a2 == 0 ) {\n    roots <- -a0/a1\n  } else {\n    discrim <- a1^2 - 4*a2*a0\n    if (discrim > 0) {\n      roots <- (-a1 +c(1,-1) * sqrt(a1^2-4*a2*a0))/(2*a2)\n    } else if (discrim == 0) {\n      roots <- -a1/(2*a2)\n    } else {\n      roots <- NULL\n    }\n  }\n  return(roots)\n}\n```\n\n\n\n#### Example : n choose r\n\nThe number of ways that you can choose r things from a set of n, ignoring the order, is \n$$ \\frac{n!}{r!(n-r)!}  $$\n```{r}\nn_factorial <-function(n) {\n  n_fact <- prod(1:n)\n  return(n_fact)\n}\nn_choose_r <- function(n, r) {\n  n_ch_r <- n_factorial(n)/n_factorial(r)/n_factorial(n-r)\n  return(n_ch_r)\n}\n```\n\n\n#### Example : Winsorised mean\nk-th Winsorised mean of x={x1, …, xn} is defined as\n$$ w_k =\\frac{(k+1)x_{k+1} + x_{k+2} + \\cdots + x_{n-k+1} + (k+1)x_{n-k}}{n} $$\n```{r}\nwmean <- function(x, k) {\n\tx <- sort(x)\n\tn <- length(x)\n\tx[1:k] <- x[k+1]\n\tx[(n-k+1):n] <- x[n-k]\n\treturn(mean(x))\n}\n```\n\n\n#### Exmple : Swap\n\nswap values of ```x[1]``` and ```x[2]```\n```{r, eval=FALSE}\nf1  swap <- function(x){\nf2    y <- x[2]\nf3    x[2] <- x[1]\nf4    x[1] <- y\nf5    return(x)\nf6  }\np1  x <- c(7, 8, 9)\np2  x[1:2] <- swap(x[1:2])\np3  x[2:3] <- swap(x[2:3])\n```\n\n\n### Scope and its consequences\n\n* Argument and variables defined within a function exist only within that function.\n   * If you define and use a variable x inside a function, it does not exist outside the function.\n   * If variables with the same name exist inside and outside a function, then they are separate and do not interact at all.\n* The variable defined outside the function can be seen inside the function (provided there is not a variable with the same name defined inside).\n\n```{r}\ntest <- function(x) {\n  y <- x+1\n  return(y)\n}\ntest(1)\n```\n```{r, eval=FALSE}\ny\n### Error : Object \"y\" not found\n```\n```{r}\ntest2 <- function(x) {\n  y <- x + z\n  return(y)\n}\nz <- 1\ntest2(1)\nz<-2\ntest2(1)\n```\n\n### Optional argument and default value\n\n* To give argument_1 the default value x1 we use argument_1 = x1 within the function definition.\n* If an argument has a default then it may be omitted when calling the function, in which case the default is used.\n\n\n```{r}\ntest3 <- function(x=1, y=1, z=1) {\n  return(x*100+y*10+z)\n}\ntest3(2,2)\ntest3(y=2, z=2)\n```\n\n### Vector-based programming\n\n* Many R functions are vectorised.\n* To further facilitate vector-based programming, R provides functions that enable the vectorisation of user-defined functions.\n* ```apply```, ```sapply```, ```lapply```, ```tapply```, and ```mapply```.\n* ```sapply(X, FUN)```\n   * apply function ```FUN``` to every element of vector ```X```.\n   \n   \n#### Example : Density of primes – sapply\n \n* Let $\\rho(n)$ be the number of primes less than or equal to n\n* Then\n$$ \\lim_{n\\rightarrow\\infty} \\frac{\\rho(n)\\log(n)}{n} \\rightarrow 1.$$\n\n* To check this, first we define a function ```prime``` that tests if a given integer is prime.\n\n* We then use ```sapply``` to apply ```prime``` to the vector ```2:n```.\n\n```{r}\nprime <- function(n) {\n  if ( n==1 ) {\n    is.prime <- FALSE\n  } else if ( n==2) {\n    is.prime <- TRUE\n  } else {\n    is.prime <- TRUE\n    for ( m in 2:(n/2) ) {\n\t\t\tif ( n%%m == 0 ) is.prime <- FALSE\n    }\n  }\n  return(is.prime)\n}\t\n```\n\n```{r}\nn <- 1000\nm.vec <- 2:n\nprimes <- sapply(m.vec, prime)\nnum.primes <- cumsum(primes)\nplot(m.vec, num.primes/m.vec, type = \"l\", main = \"prime density\", xlab = \"n\", ylab = \"\")\nlines(m.vec, 1/log(m.vec), col= \"red\")\n```\n\n### Recursive programing\n\n* A recursive program is one that calls itself.\n* This is useful because many algorithms are recursive in nature.\n\n#### n factorial\n\n```{r}\nnfact2 <- function(n) {\n  if (n==1) {\n    cat(\"called nfact2(1)\\n\")\n    return(1)\n  } else {\n    cat(\"called nfact2(\", n, \")\\n\", sep=\"\")\n    return(n*nfact2(n-1))\n  }\n}\n```\n#### Sieve of Eratosthenes\nThe Sieve of Eratosthenes is an algorithm for finding all of the primes less than or equal to a given number $n$.\n\n1. Start with the list $2,3,\\cdots,n$ and $p=2$.\n2. Remove from the list all elements that are multiples of $p$ (but keep $p$ itself).\n3. Increase $p$ to the smallest element of the remaining list that is larger than the current $p$.\n4. If $p$ is larger than $\\sqrt{n}$ then stop, otherwise go back to step 2.\n\n```{r}\nprimesieve <- function(sieved, unsieved) {\n  p <- unsieved[1]\n  n <- unsieved[length(unsieved)]\n  if ( p^2 > n ) {\n    return(c(sieved, unsieved))\n  } else {\n    unsieved <- unsieved[unsieved %% p != 0]\n    sieved <- c(sieved, p)\n    return(primesieve(sieved, unsieved))\n  }\n}\n\n```\n\n\n\n",
    "created" : 1490675134532.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3359406038",
    "id" : "22179E3",
    "lastKnownWriteTime" : 1491374763,
    "last_content_update" : 1491374763,
    "path" : "~/Dropbox/Work/Github/SSuR/4.Functions.Rmd",
    "project_path" : "4.Functions.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}